#include <stdio.h>

void nistp256_zero(double h[12])
{
  h[0]=0.0;  h[1]=0.0;  h[2]=0.0;  h[3]=0.0;  h[4]=0.0;  h[5]=0.0;
  h[6]=0.0;  h[7]=0.0;  h[8]=0.0;  h[9]=0.0;  h[10]=0.0;  h[11]=0.0; 
}

void nistp256_one(double h[12])
{
  h[0]=1.0;  h[1]=0.0;  h[2]=0.0;  h[3]=0.0;  h[4]=0.0;  h[5]=0.0;
  h[6]=0.0;  h[7]=0.0;  h[8]=0.0;  h[9]=0.0;  h[10]=0.0;  h[11]=0.0;  
}

void nistp256_copy(double h[12], const double g[12])
{
  h[0]=g[0];  h[1]=g[1];  h[2]=g[2];  h[3]=g[3];  h[4]=g[4];  h[5]=g[5];
  h[6]=g[6];  h[7]=g[7];  h[8]=g[8];  h[9]=g[9];  h[10]=g[10];  h[11]=g[11];
}

void nistp256_mulmodp(double h[12],const double f[12],const double g[12])
{
  double t[23];
  nistp256_mul(t,f,g);
  nistp256_modp(h,t);
}

void nistp256_sqmodp(double h[12],const double f[12])
{
  double t[23];
  nistp256_sq(t,f);
  nistp256_modp(h,t);
}

void nistp256_inverse(double out[12],const double f[12])
{

int i;
double r0[12];
double r1[12];
double t0[12];
double t1[12];

 nistp256_copy(r0, f);
 nistp256_sqmodp(t0,f);
 nistp256_sqmodp(t1, t0);
 
 for(i=0;i <94; i+=2){
    nistp256_mulmodp(r1, r0, t1);
    nistp256_sqmodp(t0, t1);
    nistp256_mulmodp(r0, r1, t0);
    nistp256_sqmodp(t1, t0);
}

 for(i=0;i <96; i+=2){
   nistp256_sqmodp(t0, t1);
   nistp256_sqmodp(t1, t0);
}

 nistp256_mulmodp(r1, r0, t1);
 nistp256_sqmodp(t0,t1);

 for(i=0;i <30; i+=2){
   nistp256_sqmodp(t1, t0);
   nistp256_sqmodp(t0, t1);
}

   nistp256_sqmodp(t1, t0);

 for(i=0;i <32; i+=2){
    nistp256_mulmodp(r0, r1, t1);
    nistp256_sqmodp(t0, t1);
    nistp256_mulmodp(r1, r0, t0);
    nistp256_sqmodp(t1, t0);
}
 nistp256_copy(out, r1);

}



int iszero(double f[12])
{
double r=0.0; int i;
  for(i=0;i<12;++i){r+=f[i];}
  if(r==0.0){return 1;}
  return 0;
}

int is_infi(double QX[12], double QY[12], double QZ[12]){
   int i;
   for(i=1;i<12;++i){
      if(QX[i]!=0) return 0;
      if(QY[i]!=0) return 0;
      if(QZ[i]!=0) return 0;
  }
  if(QX[0]!=1) return 0;
  if(QY[0]!=1) return 0;
  if(QZ[0]!=0) return 0;
  return 1;
}



void nistp256_pointdouble(double QX[12], double QY[12], double QZ[12], const double twoinv[12]) 
{
 
  double t0[12];  
  double t1[12]; double t1_1[12];
  double t2[12]; double t2_1[12];
  double t3[12]; double t3_1[12];
  double QX_1[12]; double QY_1[12]; double QZ_1[12];

  /*** check if Q is infinity *****/
  if(is_infi(QX, QY, QZ)) return;
  
  nistp256_sqmodp(t1, QZ);
  nistp256_sub(t2, QX, t1);
  nistp256_add(t1_1, QX, t1);
  nistp256_mulmodp(t2_1, t1_1, t2); 
  nistp256_add(t0, t2_1, t2_1);
  nistp256_add(t2, t2_1, t0); /* 3*t2 */ 
  nistp256_add(QY_1, QY, QY);
  nistp256_mulmodp(QZ_1, QY_1, QZ);
  nistp256_sqmodp(QY, QY_1);
  nistp256_mulmodp(t3, QY, QX);
  nistp256_sqmodp(QY_1, QY);
  nistp256_mulmodp(QY, QY_1, twoinv);
  nistp256_sqmodp(QX, t2);
  nistp256_add(t1_1, t3, t3);
  nistp256_sub(QX_1, QX, t1_1);
  nistp256_sub(t1_1, t3, QX_1);
  nistp256_mulmodp(t1, t1_1, t2);
  nistp256_sub(QY_1, t1, QY); 
  nistp256_copy(QX, QX_1);
  nistp256_copy(QY, QY_1);
  nistp256_copy(QZ, QZ_1);

}

void nistp256_pointadd(double* QX, double* QY, double* QZ, double* x, double* y)
{

  double t4[12]; double t4_1[12];
  double t1[12]; double t1_1[12];
  double t2[12]; double t2_1[12];
  double t3[12]; double t3_1[12];
  double QX_1[12]; double QY_1[12]; double QZ_1[12];

  /*** check if Q is infinity *****/
  if(is_infi(QX, QY, QZ)){
    nistp256_copy(QX,x);
    nistp256_copy(QY,y);
    nistp256_one(QZ);
   return;
  }

 
  nistp256_sqmodp(t1, QZ);
  nistp256_mulmodp(t2, QZ, t1);
  nistp256_mulmodp(t1_1, x, t1);
  nistp256_mulmodp(t2_1, y, t2);
  nistp256_sub(t1, t1_1, QX);
  nistp256_sub(t2, t2_1, QY); 
  
  /*** check if t1=0 *****/

  if(iszero(t1)){
    if(iszero(t2)){
      printf(  "\n t2 is zero \n");
       /* double (x,y,1) and return this point */
    }
    else{
       nistp256_one(QX); nistp256_one(QY); nistp256_zero(QZ); /* return infinity */
       return;
    }
  }


  nistp256_mulmodp(QZ_1, t1, QZ); 
  nistp256_sqmodp(t3, t1);
  nistp256_mulmodp(t4, t3, t1);
  nistp256_mulmodp(t3_1, t3, QX);
  nistp256_add(t1, t3_1, t3_1); 
  nistp256_sqmodp(QX, t2);
  nistp256_sub(QX_1, QX, t1);
  nistp256_sub(QX, QX_1, t4);
  nistp256_sub(t3, t3_1, QX);
  nistp256_mulmodp(t3_1, t3, t2);
  nistp256_mulmodp(t4_1, t4, QY);
  nistp256_sub(QY, t3_1, t4_1);
  nistp256_copy(QZ, QZ_1);

}





double powers[12] = {
  1.0 /* 2^0 */
, 4194304.0 /* 2^22 */
, 8796093022208.0 /* 2^43 */
, 18446744073709551616.0 /* 2^64 */
, 77371252455336267181195264.0 /* 2^86 */
, 162259276829213363391578010288128.0 /* 2^107 */
, 340282366920938463463374607431768211456.0 /* 2^128 */
, 1427247692705959881058285969449495136382746624.0  /* 2^150 */
, 2993155353253689176481146537402947624255349848014848.0  /* 2^171 */
, 6277101735386680763835789423207666416102355444464034512896.0 /* 2^192 */
, 26328072917139296674479506920917608079723773850137277813577744384.0  /* 2^214 */
, 55213970774324510299478046898216203619608871777363092441300193790394368.0 /* 2^235 */
} ;


double Px[12];
double Py[12];
double PX[12];
double PY[12];
double PZ[12];
double QX[12];
double QY[12];
double QZ[12];
double twoinv[12];
double Zsq[12];
double Zcube[12];

double f[12];
double g[12];
double h[23];
double r[12];
char s[32];

extern void nistp256_todouble(double [12],const char Px[23]);


const double nistp256_constants[45] = {
 2.0
, 28334198897217871282176.0 /* 2^22 (2^52 + 2^51) */
, 59421121885698253195157962752.0 /* 2^43 (2^52 + 2^51) */
, 124615124604835863084731911901282304.0 /* 2^64 (2^52 + 2^51) */
, 522673715590561479879743397015195972796416.0 /* 2^86 (2^52 + 2^51) */
, 1096126227998177188652763624537212264741949407232.0 /* 2^107 (2^52 + 2^51) */
, 2298743311298833287537520540725463775428108683275403264.0 /* 2^128 (2^52 + 2^51) */
, 9641628265553941653251772554046975615133217962696757011808256.0 /* 2^150 (2^52 + 2^51) */
, 20219960000362979846000261315264723005227858316905429360827707686912.0 /* 2^170 (2^52 + 2^51) */
, 42404329554681223909999140017830044379859613525014854994918548831022874624.0 /* 2^192 (2^52 + 2^51) */
, 177856649068517676170605032973344626462622696446423906364606849036154567126941696.0  /* 2^214 (2^52 + 2^51) */
, 372992427307339981616536686110115630075342113098010788080347982669869622759400031649792.0 /* 2^235 (2^52 + 2^51) */
, 782221814912442657127083144349201213843763863167719520244277932552082419109121295174424592384.0 /* 2^256 (2^52 + 2^51) */
, 6755399441055744.0 /* 2^0 (2^52 + 2^51) */
, 1901475900342344102245054808064.0 /* 2^48 (2^52 + 2^51) */
, 2090694862362245919518973588060783891185664.0 /* 2^88 (2^52 + 2^51) */
, 647038720011615355072008362088471136167291466140973739546486645981184.0 /* 2^176 (2^52 + 2^51) */
, 711426596274070704682420131893378505850490785785695625458427396144618268507766784.0 /* 2^216 (2^52 + 2^51) */
, 0.00000000023283064365386962890625 /* 2^-32 */
, 0.0000000000000000000542101086242752217003726400434970855712890625 /*2^-64 */
, 0.0000000000000000000000000000000000000000000000006842277657836020854119773355907793609766904013068924666782559979930620520927053718196475529111921787261962890625 /* 2^-160 */
, 0.0000000000000000000000000000000000000000000000000000000000000000000000000000086361685550944446253863518628003995711160003644362813850237034701685918031624270579715075034722882265605472939461496635969950989468319466936530037770580747746862471103668212890625 /* 2^-256 */
,3280876087174517886558753340676432048029754146339818654638655909614929498799063884835269765534580736.0 /*2^278(2^52 + 2^51) */
,6880495847970214534832462685906260822389694967504843371212766518160768628265454424210055659330377059663872.0 /*2^299(2^52 + 2^51)*/
,14429445628562431352152968786673686696196193580492717285625595729093892250304154276640966646076018911428208492544.0 /*2^320(2^52 + 2^51)*/
,60521481517661920070060605593820590804602479519434926081968578668921428641019715499132312967503230424278980593111269376.0 /*2^342(2^52 + 2^51) */
,126922746007727730998767739142292039647053699129141994102652568692685911917371778398436328404425334690737512708804484794417152.0 /*2^363(2^52 + 2^51) */
,266176290635598226519527761677736035529897959236078391216366039739003645549340059811837542985997399497349556252294742895581519151104.0 /* 2^384(2^52 + 2^51) */
,1116424280518052183883761368915974964767193130015720540592368945941461946542179210229029453896340836701331233187224849305909148101552111616.0 /*2^406(2^52 + 2^51) */
,2341311412736994173536197922344874729311448606998728363144367719719028804114824215090229577297618978369870198341054967171585981759466213979717632.0   /*2^427(2^52 + 2^51) */
,4910085911844212805019784545241398728324963069064597184224937052144200694607011832324905138488856235726330026191340106513825884818828089579992791384064.0  /*2^448(2^52 + 2^51) */
,20594392980391829144945702397244179651808305900429916228183390377556629550192968156367678921984363664931888934174442574111365963999149931437722084873345171456.0 /*2^470(2^52 + 2^51) */
,43189572427614685274981169673785425845149092335698399677767253497073640774446283555062790586597352228639240742081800593182799354132745277014481745736305573009293312.0  /*2^491(2^52 + 2^51) */
,6755399449444351.0 /* 2^0 * (2^52 + 2^51) + 2^23 - 1 */
, 442721875361206894592.0 /* 2^16 * (2^52 + 2^51) + 2^44 - 2^23 */
, 7427640272605752204627804160.0 /* 2^40 * (2^52 + 2^51) + 2^65 - 2^44 */
, 124615124759578331101916298844569600.0 /* 2^64 * (2^52 + 2^51) + 2^87 - 2^65 */
, 8166777130700150201557071026577639211008.0 /* 2^80 * (2^52 + 2^51) + 2^108 - 2^87 +2^96 */
, 137015779180336557904918721567173964800259522560.0 /* 2^104 * (2^52 + 2^51) + 2^129 - 2^108 */
, 2298743314153327992384706460965108787577884092504473600.0 /* 2^128 * (2^52 + 2^51) + 2^151 - 2^129 */
, 150650447635588190344051887199514952220412880187563758845952.0  /* 2^144 * (2^52 + 2^51) + 2^172 - 2^151 */
, 2527495012599569965212687684701316259775740315922641048331836456960.0  /* 2^168 * (2^52 + 2^51) + 2^193 - 2^172 */
, 42404329607337363467175997980108294385905406476795986592837659994143850496.0 /* 2^192 * (2^52 + 2^51) + 2^215 - 2^193 + 2^192 */
, 2779010252096517636001739320776587610810025405303320499702926051753571926409216.0  /* 2^208 * (2^52 + 2^51) + 2^236 - 2^215 -2^224 */
, 46624053529209476511441732538314839812011875558114093957940507147006404252450552807424.0  /* 2^232 * (2^52 + 2^51) + 2^256 - 2^236 */
} ;


char inv_2[32]={0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0x7F }; 






int nistp256(unsigned char ek_x[32],unsigned char ek_y[32],
  const unsigned char np256_Px[32], const unsigned char np256_Py[32],
  const unsigned char k[32])
{
  long long t1, t2; 
  int i,b;
  int pos, loop; 
  nistp256_todouble(Px, np256_Px);
  nistp256_todouble(Py, np256_Py);
  nistp256_todouble(twoinv, inv_2);
  nistp256_copy(PX, Px); /* P in jacobian coord */
  nistp256_copy(PY, Py);
  nistp256_one(PZ);
  nistp256_one(QX); /* initialize Q to infinity */
  nistp256_one(QY);
  nistp256_zero(QZ);



  
  for(pos=255; pos>=0; --pos){
    b = k[pos/8] >> (pos & 7);
    b&=1;
    nistp256_pointdouble(QX, QY, QZ, twoinv); 
    if(b) nistp256_pointadd(QX, QY, QZ, Px, Py);
  }



  nistp256_inverse(f,QZ); /* z^-1 */
  nistp256_sqmodp(g,f);   /* Z^-2 */
  nistp256_mulmodp(r,g,f); /* Z^-3 */
  nistp256_mulmodp(Px,g,QX);
  nistp256_mulmodp(Py,r,QY);

  nistp256_freeze(ek_x, Px);
  nistp256_freeze(ek_y, Py);



return 0;

}




