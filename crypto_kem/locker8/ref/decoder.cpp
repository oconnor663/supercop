/** 
 * \file decoder.cpp
 * \brief Implementation of decoder.h
 */

#include "decoder.h"
#include "ffi.h"
#include "ffi_elt.h"
#include "ffi_vec.h"



/** 
 * \fn static void expand_space(ffi_vec &S, unsigned int &S_dim, unsigned int E_expected_dim, ffi_vec F,  unsigned int F_dim)
 * \brief This function expands the space S until its dimension is F_dim * E_expected_dim.
 *
 * This algorithm may return a space <b>S</b> such that <b>dim_S <= F_dim * E_expected_dim</b> ; the DFR associated to each parameter set is given in the supporting documentation.
 *
 * \param[out] S Subspace generated by the coordinates of the syndrom
 * \param[out] S_dim Dimension of the space <b>S</b>
 * \param[in] E_expected_dim Expected dimension of the support <b>E</b>
 * \param[in] F Support of the LRPC matrix H
 * \param[in] F_dim Dimension of the support <b>F</b>
 */
static void expand_space(ffi_vec &S, unsigned int &S_dim, unsigned int E_expected_dim, ffi_vec F,  unsigned int F_dim) {
  // Compute the spaces Si = F[i]^(-1) * S
  ffi_vec Si[F_dim];
  ffi_elt Fi_inv;
  unsigned int Si_dim = S_dim;
  for(unsigned int i = 0 ; i < F_dim ; ++i) {
    ffi_elt_inv(Fi_inv, F[i]);
    ffi_vec_scalar_mul(Si[i], S, Fi_inv, Si_dim);
  }

  // Compute the spaces inters[i] as the intersection between Si and Si+1
  ffi_vec inters[F_dim-1];
  unsigned int inters_dim[F_dim-1];
  for(unsigned int i = 0 ; i < F_dim - 1 ; ++i) {
    ffi_vec_intersection(inters[i], inters_dim[i], Si[i], Si_dim, Si[i+1], Si_dim);
  }

  // Expand S until its dimension is F_dim * E_expected_dim
  ffi_vec inter, directSum1, directSum, add, tmp, sommeTmpS;
  unsigned int inter_dim, unions_dim, tmp_dim, somme_dim;
  for(unsigned int i = 0 ; i < F_dim - 2 ; ++i) {
    ffi_vec_intersection(inter, inter_dim, Si[i], Si_dim, Si[i+2], Si_dim);

    ffi_vec_directsum(directSum1, inters[i], inters_dim[i], inters[i+1], inters_dim[i+1]);
    ffi_vec_directsum(directSum, directSum1, inters_dim[i] + inters_dim[i+1], inter, inter_dim);
    unions_dim = ffi_vec_gauss(directSum, inters_dim[i] + inters_dim[i+1] + inter_dim);

    ffi_vec_tensor_mul(add, F, F_dim, directSum, unions_dim);
    ffi_vec_directsum(tmp, S, S_dim, add, F_dim * unions_dim);
    tmp_dim = ffi_vec_gauss(tmp, S_dim + F_dim * unions_dim);

    if(tmp_dim > F_dim * E_expected_dim) continue;
    else {
      ffi_vec_directsum(sommeTmpS, S, S_dim, tmp, tmp_dim);
      somme_dim = ffi_vec_gauss(sommeTmpS, S_dim + tmp_dim);
      ffi_vec_set(S, sommeTmpS, somme_dim);
      S_dim = somme_dim;
    }
  }
}



/** 
 * \fn void RS_recover(ffi_vec& E, unsigned int E_expected_dim, const ffi_vec& F, unsigned int F_dim, const ffi_vec& xc, unsigned int xc_size)
 * \brief This function implements the decoding algorithm of the LRPC codes.
 *
 * As explained in the supporting documentation, the provided decoding algorithm works as follows (see \cite gaborit2013low for details):
 *   1. Compute the space <b>S</b> generating by the coordinates of <b>xc</b> ;
 *   2. Compute the spaces <b>Si</b> = <b>F[i]^(-1)</b> * <b>S</b> ;
 *   3. Retrieve the support <b>E</b> by computing the intersection of the spaces <b>Si</b>
 *
 * This algorithm may fail to retrieve the support <b>E</b> ; the DFR associated to each parameter set is given in the supporting documentation.
 *
 * \param[out] E Support of the error vector
 * \param[in] E_expected_dim Expected dimension of the support <b>E</b>
 * \param[in] F Support of the LRPC matrix H
 * \param[in] F_dim Dimension of the support <b>F</b>
 * \param[in] xc the syndrom to decode
 * \param[in] xc_size Size of the vector <b>xc</b>
 */
int RS_recover(ffi_vec& E, unsigned int E_expected_dim, const ffi_vec& F, unsigned int F_dim, const ffi_vec& xc, unsigned int xc_size) {
  // Compute the space S generated by the coordinates of xc and
  // expand it until its dimension is F_dim * E_expected_dim
  ffi_vec S;
  ffi_vec_set(S, xc, xc_size);
  unsigned int S_dim = ffi_vec_gauss(S, xc_size);
  expand_space(S, S_dim, E_expected_dim, F, F_dim);

  #ifdef VERBOSE
    printf("\n\nS after expansion:"); ffi_vec_print(S, S_dim);
  #endif

  // Compute the spaces Si = F[i]^(-1) * S
  ffi_vec Si[F_dim];
  ffi_elt Fi_inv;
  for(unsigned int i = 0 ; i < F_dim ; ++i) {
    ffi_elt_inv(Fi_inv, F[i]);
    ffi_vec_scalar_mul(Si[i], S, Fi_inv, S_dim);
  }

  // Retrieve the support E by computing the intersection of the Si spaces
  unsigned int E_dim;
  ffi_vec_intersection(E, E_dim, Si[0], S_dim, Si[1], S_dim);

  if(E_dim > E_expected_dim) {
    for(unsigned int i = 2 ; i < F_dim ; ++i) {
      ffi_vec_intersection(E, E_dim, E, E_dim, Si[i], S_dim); 
      if(E_dim <= E_expected_dim) break;
    }
  }

  ffi_vec_echelonize(E, E_dim);

  return E_dim;
}

